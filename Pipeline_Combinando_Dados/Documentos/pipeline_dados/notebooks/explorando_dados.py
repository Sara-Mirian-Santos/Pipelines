# -*- coding: utf-8 -*-
"""usando csv e json para unificar num arquivo só

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tf3gd4RfOM0Ry-J3i9I53JX8VMWYR_BP

Instalações

pip install requests==2.28.2
pip install pandas==2.0.0

"""

"""Visualizando dados e extraindo valores"""

#passo o caminho do arquivo que quero ler
path_json = '/content/documentos/pipeline_dados/data_raw/dados_empresaA.json'

#abro o arquivo para leitura, e mostro o conteúdo
with open(path_json, 'r') as file:
    #a função readline() lê a primeira linha deste arquivo.
    print(file.readline())

with open(path_json, 'r') as file:
    dados = (file.readline())

type(dados)

dados

import json

with open(path_json, 'r') as file:
    dados_json = json.load(file)

dados_json[0]

"""Json ele é tratado como uma lista
Já os dados são tratados com oum dicionario
"""

type(dados_json)

type(dados_json[1])

"""Lendo CSV (arquivo separado por virgulas)"""

path_csv = '/content/documentos/pipeline_dados/data_raw/dados_empresaB.csv'

with open(path_csv, 'r') as file:
    print(file.readlines())

# readlines para ver se tem varias linhas

with open(path_csv, 'r') as file:
    print(file.readlines()[0])

# readlines para ver se tem varias linhas

with open(path_csv, 'r') as file:
    dados_csv = file.readlines()

dados_csv[0]  #nome das colunas

dados_csv[1]  #valores dos produtos

"""Acessando as colunas do csv"""

import csv

'''
O que o csv.reader faz?
Ele lê o conteúdo de um arquivo CSV.
Cada linha do arquivo é retornada como uma lista de strings (valores separados por vírgulas no CSV).
Pode ser usado em um loop for para iterar pelas linhas.
'''
with open(path_csv, 'r') as file:
  spamreader = csv.reader(file, delimiter=',')
  print(spamreader)

#spamreader pode ser iteravel
dados_csv = []
with open(path_csv, 'r') as file:
  spamreader = csv.reader(file, delimiter=',')
  for row in spamreader:
    dados_csv.append(row)

dados_csv[0]

dados_csv[0][0]

type(dados_csv)

type(dados_csv[0])

"""Transformando o csv em uma lista de dicionarios para melhor entendimento dos dados"""

#DictReader retorna um dicionario
dados_csv = []
with open(path_csv, 'r') as file:
  spamreader = csv.DictReader(file, delimiter=',')
  for row in spamreader:
    dados_csv.append(row)

"""Notas

Tuplas: Uma tupla é semelhante a uma lista, mas é imutável, ou seja, seus elementos não podem ser alterados após a criação. Elas são definidas usando parênteses ().

minha_tupla = (1, 2, 3)

Conjuntos: Um conjunto é uma coleção não ordenada de elementos únicos. Eles são criados usando chaves {} ou a função set().

meu_conjunto = {1, 2, 3}

# Comparando dados
"""

#keys usado para pegar o valor das keys num dicionario
nome_colunas_json = list(dados_json[0].keys())
nome_colunas_json

#len numero de itens na lista
len(nome_colunas_json)

nome_colunas_csv = list(dados_csv[0].keys())
nome_colunas_csv

#csv tem uma coluna a mais
len(nome_colunas_csv)

"""Notas

.items()
Este método retorna uma visão dos pares chave-valor do dicionário.

---

print(meu_dicionario.items())

Saída: dict_items([('nome', 'João'), ('idade', 25), ('cidade', 'Rio de Janeiro')])

No cenario real, perguntar para os analistas de bi qual nome de coluna faz mais sentido

voltando vamos manter os nomes das colunas do json, então vamos mudar as colunas do csv
"""

#mapping mapeamento
#criando um dicionario = {'nome_csv': 'nome_json',
key_mapping = {'Nome do Item': 'Nome do Produto',
                'Classificação do Produto': 'Categoria do Produto',
                'Valor em Reais (R$)': 'Preço do Produto (R$)',
                'Quantidade em Estoque': 'Quantidade em Estoque',
                'Nome da Loja': 'Filial',
                'Data da Venda': 'Data da Venda'}
key_mapping

#reescrevedo todas as colunas da lista para o novo nome de cada coluna

new_dados_csv = []                                #crio uma lista vazia

for old_dict in dados_csv:                        #crio um for para percorrer cada item da lista
    dict_temp = {}                                #crio um dicionario vazio que vai receber os novos valores
    for old_key, value in old_dict.items():       #items faz com que o for retorne os dois valores do dicionario
        dict_temp[key_mapping[old_key]] = value   #procuro se a coluna existe se nao a crio e adiciono um valor a ela
    new_dados_csv.append(dict_temp)               #na lista new_dados_csv adicio o item a coluna correspondente
new_dados_csv[0]

'''
Para cada livro da lista original, cria-se um dicionário temporário. Utilizando o método .items(),
o código identifica e substitui a abreviação da categoria pelo nome completo apenas quando a chave é "categoria",
mantendo as demais chaves e valores inalterados. Ao final da iteração para cada livro, o dicionário temporário atualizado
é adicionado a uma nova lista, garantindo a preservação da estrutura original sem modificar diretamente os dicionários
na lista original.
'''
categorias = {"FIC": "Ficção", "BIO": "Biografia", "HIS": "História", "SCI": "Ciência", "PHI": "Filosofia"}
livros_atualizados = []
lista_livros = []

for livro in lista_livros:
    livro_temp = {}
    for k, v in livro.items():
        if k == "categoria":
            livro_temp[k] = categorias[v]
        else:
            livro_temp[k] = v
    livros_atualizados.append(livro_temp)

"""Juntando os arquivos"""

#1 verificando união, verifique quantos registros tem em cada arquivo
len(dados_json)

len(new_dados_csv)

#valor esperado apos a união
soma = (len(dados_json)+len(new_dados_csv))
soma

#extend adiciona uma nova lista ao final da lista existente ou em listas vazias
combined_list = []
combined_list.extend(dados_json)
combined_list.extend(new_dados_csv)

len(combined_list)

"""Pesquisando valores nulos na lista e tratando"""

'''
combined_list[0]['Data da Venda']

Retorno do notebook:
KeyError: 'Data da Venda'
-----------------------------------
#o get procura na lista algo e retorna 'Indisponível'
combined_list[0].get('Data da Venda', 'Indisponível')

Retorno do notebook:
''Indisponível''
'''

"""Nos campos vazios no json vamos adicionar o valor Indisponível, para não dar erro na unificação

Tratando o json, transformando ele numa lista de listas
"""

nomes_colunas = list(combined_list[-1].keys())  #pego o ultimo item da lista pois ela tera todas as colunas que eu quero
nomes_colunas

#agora consigo definir as colunas

#crio uma tabela nova vazia e adiciono o nome de cada coluna e seu valor
dados_combinados_tabela = [nomes_colunas]

for row in combined_list:
    linha = []
    for coluna in nomes_colunas:
        linha.append(row.get(coluna, 'Indisponivel')) #quando o get bscar um valor e nnão encontrar retorna 'Indisponivel'
    dados_combinados_tabela.append(linha)

dados_combinados_tabela[0]

dados_combinados_tabela[1]

"""Salvando os dados da nova lista em um arquivo csv"""

path_dados_combinados = '/content/documentos/pipeline_dados/data_processed/dados_combinados.csv'
with open(path_dados_combinados, 'w') as file:
    writer = csv.writer(file)
    writer.writerows(dados_combinados_tabela) #writerows - itera cada linha da lista automaticamente

